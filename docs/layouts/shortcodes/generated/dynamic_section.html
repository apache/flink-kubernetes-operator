<table class="configuration table table-bordered">
    <thead>
        <tr>
            <th class="text-left" style="width: 20%">Key</th>
            <th class="text-left" style="width: 15%">Default</th>
            <th class="text-left" style="width: 10%">Type</th>
            <th class="text-left" style="width: 55%">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><h5>kubernetes.operator.checkpoint.trigger.grace-period</h5></td>
            <td style="word-wrap: break-word;">1 min</td>
            <td>Duration</td>
            <td>The interval before a checkpoint trigger attempt is marked as unsuccessful.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.checkpoint.type</h5></td>
            <td style="word-wrap: break-word;">FULL</td>
            <td><p>Enum</p></td>
            <td>Type of checkpoint.<br /><br />Possible values:<ul><li>"FULL": A comprehensive snapshot, saving the complete state of a data stream.</li><li>"INCREMENTAL": A more efficient, reduced snapshot, saving only the differences in state data since the last checkpoint.</li><li>"UNKNOWN": Only for internal purposes.</li></ul></td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.cluster.health-check.checkpoint-progress.enabled</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Whether to enable checkpoint progress health check for clusters.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.cluster.health-check.checkpoint-progress.window</h5></td>
            <td style="word-wrap: break-word;">5 min</td>
            <td>Duration</td>
            <td>If no checkpoints are completed within the defined time window, the job is considered unhealthy. This must be bigger than checkpointing interval.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.cluster.health-check.enabled</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Whether to enable health check for clusters.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.cluster.health-check.restarts.threshold</h5></td>
            <td style="word-wrap: break-word;">64</td>
            <td>Integer</td>
            <td>The threshold which is checked against job restart count within a configured window. If the restart count is reaching the threshold then full cluster restart is initiated.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.cluster.health-check.restarts.window</h5></td>
            <td style="word-wrap: break-word;">2 min</td>
            <td>Duration</td>
            <td>The duration of the time window where job restart count measured.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.deployment.readiness.timeout</h5></td>
            <td style="word-wrap: break-word;">5 min</td>
            <td>Duration</td>
            <td>The timeout for deployments to become ready/stable before being rolled back if rollback is enabled.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.deployment.rollback.enabled</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Whether to enable rolling back failed deployment upgrades.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.exception.label.mapper</h5></td>
            <td style="word-wrap: break-word;"></td>
            <td>Map</td>
            <td>Key-Value pair where key is the REGEX to filter through the exception messages and value is the string to be included in CR status error label field if the REGEX matches. Expected format: headerKey1:headerValue1,headerKey2:headerValue2.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.jm-deployment-recovery.enabled</h5></td>
            <td style="word-wrap: break-word;">true</td>
            <td>Boolean</td>
            <td>Whether to enable recovery of missing/deleted jobmanager deployments.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.jm-deployment.shutdown-ttl</h5></td>
            <td style="word-wrap: break-word;">86400000 ms</td>
            <td>Duration</td>
            <td>Time after which jobmanager pods of terminal application deployments are shut down.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.jm-deployment.startup.probe.enabled</h5></td>
            <td style="word-wrap: break-word;">true</td>
            <td>Boolean</td>
            <td>Enable job manager startup probe to allow detecting when the jobmanager could not submit the job.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.job.drain-on-savepoint-deletion</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Indicate whether the job should be drained when stopping with savepoint.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.job.restart.failed</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Whether to restart failed jobs.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.job.savepoint-on-deletion</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Indicate whether a savepoint must be taken when deleting a FlinkDeployment or FlinkSessionJob.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.job.upgrade.ignore-pending-savepoint</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Whether to ignore pending savepoint during job upgrade.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.job.upgrade.inplace-scaling.enabled</h5></td>
            <td style="word-wrap: break-word;">true</td>
            <td>Boolean</td>
            <td>Whether to enable inplace scaling for Flink 1.18+ using the resource requirements API. On failure or earlier Flink versions it falls back to regular full redeployment.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.job.upgrade.last-state-fallback.enabled</h5></td>
            <td style="word-wrap: break-word;">true</td>
            <td>Boolean</td>
            <td>Enables last-state fallback for savepoint upgrade mode. When the job is not running thus savepoint cannot be triggered but HA metadata is available for last state restore the operator can initiate the upgrade process when the flag is enabled.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.job.upgrade.last-state.max.allowed.checkpoint.age</h5></td>
            <td style="word-wrap: break-word;">(none)</td>
            <td>Duration</td>
            <td>Max allowed checkpoint age for initiating last-state upgrades on running jobs. If a checkpoint is not available within the desired age (and nothing in progress) a savepoint will be triggered.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.periodic.checkpoint.interval</h5></td>
            <td style="word-wrap: break-word;">(none)</td>
            <td>String</td>
            <td>Option to enable automatic checkpoint triggering. Can be specified either as a Duration type (i.e. '10m') or as a cron expression in Quartz format (6 or 7 positions, see http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).The triggering schedule is not guaranteed, checkpoints will be triggered as part of the regular reconcile loop. NOTE: checkpoints are generally managed by Flink. This setting isn't meant to replace Flink's checkpoint settings, but to complement them in special cases. For instance, a full checkpoint might need to be occasionally triggered to break the chain of incremental checkpoints and consolidate the partial incremental files. WARNING: not intended to be used together with the cron-based periodic checkpoint triggering</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.periodic.savepoint.interval</h5></td>
            <td style="word-wrap: break-word;">(none)</td>
            <td>String</td>
            <td>Option to enable automatic savepoint triggering. Can be specified either as a Duration type (i.e. '10m') or as a cron expression in Quartz format (6 or 7 positions, see http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).The triggering schedule is not guaranteed, savepoints will be triggered as part of the regular reconcile loop. WARNING: not intended to be used together with the cron-based periodic savepoint triggering</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.pod-template.merge-arrays-by-name</h5></td>
            <td style="word-wrap: break-word;">false</td>
            <td>Boolean</td>
            <td>Configure the array merge behaviour during pod merging. Arrays can be either merged by position or name matching.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.savepoint.cleanup.enabled</h5></td>
            <td style="word-wrap: break-word;">true</td>
            <td>Boolean</td>
            <td>Whether to enable clean up of savepoint history.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.savepoint.format.type</h5></td>
            <td style="word-wrap: break-word;">CANONICAL</td>
            <td><p>Enum</p></td>
            <td>Type of the binary format in which a savepoint should be taken.<br /><br />Possible values:<ul><li>"CANONICAL": A canonical, common for all state backends format. It lets you switch state backends.</li><li>"NATIVE": A format specific for the chosen state backend, in its native binary format. Might be faster to take and restore from than the canonical one.</li></ul></td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.savepoint.history.max.age</h5></td>
            <td style="word-wrap: break-word;">86400000 ms</td>
            <td>Duration</td>
            <td>Maximum age for savepoint history entries to retain. Due to lazy clean-up, the most recent savepoint may live longer than the max age.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.savepoint.history.max.count</h5></td>
            <td style="word-wrap: break-word;">10</td>
            <td>Integer</td>
            <td>Maximum number of savepoint history entries to retain.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.savepoint.trigger.grace-period</h5></td>
            <td style="word-wrap: break-word;">1 min</td>
            <td>Duration</td>
            <td>The interval before a savepoint trigger attempt is marked as unsuccessful.</td>
        </tr>
        <tr>
            <td><h5>kubernetes.operator.user.artifacts.http.header</h5></td>
            <td style="word-wrap: break-word;">(none)</td>
            <td>Map</td>
            <td>Custom HTTP header for HttpArtifactFetcher. The header will be applied when getting the session job artifacts. Expected format: headerKey1:headerValue1,headerKey2:headerValue2.</td>
        </tr>
    </tbody>
</table>
